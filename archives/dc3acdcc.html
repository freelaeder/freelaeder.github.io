<!DOCTYPE html><html lang="en" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>JavaScript面试基础理论 | freelaeder</title><meta name="keywords" content="js,JavaScript面试基础理论"><meta name="author" content="freelaeder"><meta name="copyright" content="freelaeder"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="JavaScript面试基础理论目录 变量类型和计算 原型和原型链 new操作的实现过程 闭包和作用域 异步和单线程   跨域 安全性 http相关   模块化开发   手工实现系列 手写一个深度拷贝 防抖与节流   函数式编程  变量类型和计算变量类型：值类型 + 引用类型引用类型中变量只是对真实对象的一个指针 引用类型可以无限制扩展属性 存储方式值类型： 存储在 栈(stack) 中，占据空间">
<meta property="og:type" content="article">
<meta property="og:title" content="JavaScript面试基础理论">
<meta property="og:url" content="https://freelaeder.github.io/archives/dc3acdcc.html">
<meta property="og:site_name" content="freelaeder">
<meta property="og:description" content="JavaScript面试基础理论目录 变量类型和计算 原型和原型链 new操作的实现过程 闭包和作用域 异步和单线程   跨域 安全性 http相关   模块化开发   手工实现系列 手写一个深度拷贝 防抖与节流   函数式编程  变量类型和计算变量类型：值类型 + 引用类型引用类型中变量只是对真实对象的一个指针 引用类型可以无限制扩展属性 存储方式值类型： 存储在 栈(stack) 中，占据空间">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://freelaeder.github.io/img/wallseven/wallseven10.png">
<meta property="article:published_time" content="2022-06-24T14:53:00.000Z">
<meta property="article:modified_time" content="2022-06-27T03:29:55.666Z">
<meta property="article:author" content="freelaeder">
<meta property="article:tag" content="js">
<meta property="article:tag" content="JavaScript面试基础理论">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://freelaeder.github.io/img/wallseven/wallseven10.png"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://freelaeder.github.io/archives/dc3acdcc"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta name="baidu-site-verification" content="code-OYFyQ01IKH"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"We didn't find any results for the search: ${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":366},
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: 'days',
  date_suffix: {
    just: 'Just',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: {"limitCount":50,"languages":{"author":"Author: freelaeder","link":"Link: ","source":"Source: freelaeder","info":"Copyright is owned by the author. For commercial reprints, please contact the author for authorization. For non-commercial reprints, please indicate the source."}},
  lightbox: 'mediumZoom',
  Snackbar: undefined,
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isanchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'JavaScript面试基础理论',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-06-27 11:29:55'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    })(window)</script><link rel="stylesheet" href="/css/main.css"><!-- hexo injector head_end start --><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/assets/font-awesome-animation.min.css" media="defer" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/tag_plugins.css" media="defer" onload="this.media='all'"><script src="https://npm.elemecdn.com/hexo-butterfly-tag-plugins-plus@latest/lib/assets/carousel-touch.js"></script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 5.4.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">Loading...</div></div></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="author-avatar"><img class="avatar-img" src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/img/header.svg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">93</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">Tags</div><div class="length-num">97</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">Categories</div><div class="length-num">15</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> freelaeder</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> hole</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/fine/"><i class="fa-fw fas fa-list"></i><span> fine</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> friends</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> me</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/img/wallseven/wallseven10.png')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">freelaeder</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> Search</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> freelaeder</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> hole</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/fine/"><i class="fa-fw fas fa-list"></i><span> fine</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> friends</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> me</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">JavaScript面试基础理论</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2022-06-24T14:53:00.000Z" title="Created 2022-06-24 22:53:00">2022-06-24</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2022-06-27T03:29:55.666Z" title="Updated 2022-06-27 11:29:55">2022-06-27</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/js/">js</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">Word count:</span><span class="word-count">7.8k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">Reading time:</span><span>26min</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="JavaScript面试基础理论"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post View:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="JavaScript面试基础理论"><a href="#JavaScript面试基础理论" class="headerlink" title="JavaScript面试基础理论"></a>JavaScript面试基础理论</h1><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ul>
<li><strong><a href="#变量类型和计算">变量类型和计算</a></strong></li>
<li><strong><a href="#原型和原型链">原型和原型链</a></strong></li>
<li><strong><a href="#new操作的实现过程">new操作的实现过程</a></strong></li>
<li><strong><a href="#闭包和作用域">闭包和作用域</a></strong></li>
<li><strong><a href="#异步和单线程">异步和单线程</a></strong></li>
</ul>
<ul>
<li><strong><a href="#跨域">跨域</a></strong></li>
<li><strong><a href="#安全性">安全性</a></strong></li>
<li><strong><a href="#http相关">http相关</a></strong></li>
</ul>
<ul>
<li><strong><a href="#模块化开发">模块化开发</a></strong></li>
</ul>
<ul>
<li><strong><a href="#手工实现系列">手工实现系列</a></strong></li>
<li><strong><a href="#手写一个深度拷贝">手写一个深度拷贝</a></strong></li>
<li><strong><a href="#防抖与节流">防抖与节流</a></strong></li>
</ul>
<ul>
<li><strong><a href="#函数式编程">函数式编程</a></strong></li>
</ul>
<h2 id="变量类型和计算"><a href="#变量类型和计算" class="headerlink" title="变量类型和计算"></a>变量类型和计算</h2><h3 id="变量类型：值类型-引用类型"><a href="#变量类型：值类型-引用类型" class="headerlink" title="变量类型：值类型 + 引用类型"></a>变量类型：值类型 + 引用类型</h3><p>引用类型中变量只是对真实对象的一个指针</p>
<p>引用类型可以无限制扩展属性</p>
<h3 id="存储方式"><a href="#存储方式" class="headerlink" title="存储方式"></a>存储方式</h3><p><strong>值类型：</strong> 存储在 栈(stack) 中，占据空间小，大小固定。</p>
<p><strong>引用类型：</strong> 同时存储在 栈 和 堆(heap) 中，占据空间大，大小不固定。引用类型在栈中存储了指针，该指针指向堆中该实体的起始地址，当解释器寻找引用值时，会首先检索其在栈中的地址，取得地址后从堆中获取实体。</p>
<h3 id="typeof：有-8-种类型"><a href="#typeof：有-8-种类型" class="headerlink" title="typeof：有 8 种类型"></a>typeof：有 8 种类型</h3><p>typeof可以精准识别出值类型，但是无法精准识别出 引用类型。</p>
<p>对于引用类型，typeof 只能识别出是 object 或 function。</p>
<blockquote>
<p>array、null、object 都会被 typeof 识别为 object 类型</p>
</blockquote>
<ol>
<li>undefined</li>
<li>string</li>
<li>number</li>
<li>boolean</li>
<li>object</li>
<li>function</li>
<li>symbol(ES6新增)</li>
<li>BigInt(ES10新增)</li>
</ol>
<h3 id="变量计算"><a href="#变量计算" class="headerlink" title="变量计算"></a>变量计算</h3><p>以下只针对 值类型 变量计算。</p>
<p><strong>加号 + ：</strong></p>
<ol>
<li>number + number   —&gt;   number + number</li>
<li>number + string   —&gt;   String(number) + string</li>
</ol>
<p><strong>双等号 == ：</strong></p>
<ol>
<li>number == string  —&gt;  string(number) == string</li>
<li>number == ‘’   —&gt;  boolean(number) == boolean(‘’)</li>
<li>null == undefined   —&gt;  boolean(null) == boolean(undefined)</li>
</ol>
<blockquote>
<p>使用双等 == ，JS 会先尝试将两侧对比转换成 string 类型，看是否相等，若不相等再尝试转换成 boolean 类型，如果依然还不相等 才会返回计算结果 false</p>
<p>三等 === 不会出现以上情况。</p>
</blockquote>
<p>除了 if(obj.a == null){…} 之外，其他地方都推荐使用 三等。</p>
<p>obj.a == null 相当于：if(obj.a === null || obj.a === undefined){…}</p>
<p><strong>条件判断 if 语句：</strong></p>
<p>会尝试将 参数 转化为 boolean 类型。</p>
<p><strong>逻辑运算：</strong></p>
<p>&amp;&amp;：对比对象均会尝试转化为 boolean 类型</p>
<p>|| ：先将对比的前者转化为 boolean 类型，若为 true 则返回前者本身的值，若为 false 则返回 后者本身的值</p>
<p>! ：将对比对象转化为 boolean 类型，并返回该结果的相反结果</p>
<p>!! ：会将对比对象转化为 boolean 类型，并返回该结果</p>
<h3 id="JS内置构造函数类型：一共-10-种"><a href="#JS内置构造函数类型：一共-10-种" class="headerlink" title="JS内置构造函数类型：一共 10 种"></a>JS内置构造函数类型：一共 10 种</h3><ol>
<li>String</li>
<li>Number</li>
<li>Boolean</li>
<li>Array</li>
<li>Object</li>
<li>Function</li>
<li>Date</li>
<li>RegExp (regular expression)</li>
<li>Error</li>
<li>Symbol</li>
</ol>
<blockquote>
<p>Math、JSON 等等都是 JS 中是内置对象，而不是内置构造函数类型，他们的构造函数类型都是：Object</p>
<p>eval()、encodeURL()、isNaN() 等等都是  JS 中的内置函数，而不是内置构造函数类型，他们的构造函数类型都是：Function</p>
<p>NaN、Infinity、undefined、globalThis 这些都是 JS 中的内置属性值，他们是具体的值，不是函数，若使用 typeof xxx，得到的是他们值的类型(注意不是构造函数类型)</p>
</blockquote>
<h3 id="undefined与undeclared、null的区别"><a href="#undefined与undeclared、null的区别" class="headerlink" title="undefined与undeclared、null的区别"></a>undefined与undeclared、null的区别</h3><p>undefined：在作用域中已声明，但未赋值的变量</p>
<p>undeclared：还没有在作用域中声明的变量</p>
<blockquote>
<p>引用 undeclared 变量会报错：ReferenceError: xx is not defined.</p>
</blockquote>
<p>null：代表空对象(事实上并不是真正的对象)</p>
<blockquote>
<p>在最初的 32 为系统中，为了性能考虑使用低位存储变量的类型信息，000 开头代表对象，然而 null 表示为全 0，所以错误得判断 null 也为 object，虽然目前 JS 内部已经做了修正，但这个 bug 一直沿用至今。</p>
</blockquote>
<h3 id="和-的valueOf和toString的结果是什么"><a href="#和-的valueOf和toString的结果是什么" class="headerlink" title="{}和[]的valueOf和toString的结果是什么"></a>{}和[]的valueOf和toString的结果是什么</h3><div class="table-container">
<table>
<thead>
<tr>
<th>运行</th>
<th>{}</th>
<th>[]</th>
</tr>
</thead>
<tbody>
<tr>
<td>valueOf()</td>
<td>{}</td>
<td>“[object Object]”</td>
</tr>
<tr>
<td>toString()</td>
<td>[]</td>
<td>“”</td>
</tr>
</tbody>
</table>
</div>
<h3 id="赋值运算"><a href="#赋值运算" class="headerlink" title="赋值运算"></a>赋值运算</h3><p>赋值运算是从右往左进行计算执行的。</p>
<p>JS 在非严格模式下，若一个变量没有使用 var/let 声明，则 JS 默认会自动帮你声明。</p>
<p>两种情况叠加，于是，会出现下面的情况：</p>
<ol>
<li>let a = b = 3 其实相当于：b = 3;  let a = b;</li>
<li>b 会被 JS 自动定义，且为全局变量</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function myFun() &#123;</span><br><span class="line">    let a = b = 3</span><br><span class="line">&#125;</span><br><span class="line">myFun()</span><br><span class="line">console.log(b) // 3</span><br></pre></td></tr></table></figure>
<blockquote>
<p>上述代码仅在 JS 非严格模式下 可以正常运行</p>
</blockquote>
<h2 id="原型和原型链"><a href="#原型和原型链" class="headerlink" title="原型和原型链"></a>原型和原型链</h2><p><strong>一道经典面试题</strong></p>
<p>如何判断一个对象是数组类型？</p>
<p>首先 typeof xxx 是不可以的，因为 typeof 返回的是该对象的 内置类型，typeof array 得到的是 Object。</p>
<p>所谓 “数组类型” 是指 构造函数为 Array，一个对象是数组类型真正想表达的是：一个对象的构造函数是Array。</p>
<p>因此需要判断和获取 对象的构造函数 是什么。</p>
<p><strong>第1种方式：</strong></p>
<p>使用 instanceof 来判断 对象的原型链是否为 JS 内置构造函数 Array</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const arr = []</span><br><span class="line">console.log(arr instanceof Array) //true</span><br></pre></td></tr></table></figure>
<blockquote>
<p>instanceof 的本质就是不断查找(一层一层查找) 变量的 <code>__proto__.constructor</code>值，直到最深处为 null 为止，若中间发现有和 要比较的类型函数相同，则返回 true</p>
</blockquote>
<p><strong>第2种方式</strong>：</p>
<p>使用 <code>__proto__</code> 来判断对象的隐式原型构造函数是否为 Aarray的构造函数</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const arr = []</span><br><span class="line">console.log(arr.__proto__  === Array.prototype)</span><br></pre></td></tr></table></figure>
<p>或者这样写：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const arr = []</span><br><span class="line">console.log(arr.__proto__.constructor === Array)</span><br></pre></td></tr></table></figure>
<p><strong>第3种方式：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const arr = []</span><br><span class="line">console.log(arr.constructor === Array)</span><br></pre></td></tr></table></figure>
<p>或者是：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">console.log(arr.constructor.name === &#x27;Array&#x27;)</span><br></pre></td></tr></table></figure>
<p><strong>第4种方式：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const arr = []</span><br><span class="line">console.log(Object.getPrototypeOf(arr) === Array.prototype)</span><br></pre></td></tr></table></figure>
<p><strong>第5种方式：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const arr = []</span><br><span class="line">console.log(Array.isArray(arr))</span><br></pre></td></tr></table></figure>
<p><strong>函数 VS 构造函数</strong></p>
<p>所谓函数，就是可以重复执行的代码块，只定义一次但是可以被执行或调用任意次。</p>
<p>从功能上来划分，函数分为：普通函数和构造函数</p>
<p>普通函数就是使用 function 定义并且有明确返回值且返回值的函数，主要作用是用来执行或计算。</p>
<p>构造函数就是使用 function 定义并且没有明确返回值的函数，JS 会给他们自动隐形添加 return this，主要作用是用来初始化一个对象。构造函数需要通过 new 来配合使用。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function myFun()&#123;</span><br><span class="line">  this.xx = xx</span><br><span class="line">  // return this 默认普通函数会自动添加这一句</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>函数名一般采用驼峰命名法，通常约定，如果是普通函数则首字母小写，如果是构造函数则首字母大写</p>
</blockquote>
<p>普通函数也可以作为构造函数存在。</p>
<p>箭头函数是没有构造函数的，也就是说箭头函数本身并不会默认自动添加上 return this 这行隐形的代码。</p>
<p>自己手工添加的 return xxx 本质上是返回函数运行结果。</p>
<p><strong>函数参数</strong></p>
<p>普通函数和构造函数都有 arguments 对象，该属性为一个类似数组的对象，数组元素为所有参数。</p>
<p>箭头函数没有 arguments 对象。</p>
<h3 id="何为原型"><a href="#何为原型" class="headerlink" title="何为原型"></a>何为原型</h3><p>在 JS 中使用构造函数来创建新的对象，每个构造函数内部都有一个 prototype 属性，该属性是一个对象，这个对象包含了可以由该构造函数的所有实例共享的属性和方法，而这个对象被称为这个实例的原型。</p>
<h3 id="原型规则"><a href="#原型规则" class="headerlink" title="原型规则"></a>原型规则</h3><p>所有的引用类型(数字、对象、函数)都遵循以下 4 个原则：</p>
<ol>
<li><p>都具有对象特性，都可以自由无限扩展属性，除了 null 以外。</p>
</li>
<li><p>都有一个 <code>__proto__</code> 属性，属性值为对象的隐式构造函数的原型</p>
</li>
<li><p>当试图得到一个对象的某属性时，如果对象本身(显示原型)没有这个属性，则会去他的 <code>__proto__</code> (隐式原型) 中寻找</p>
<blockquote>
<p>有一种特殊情况，就是在 for(item in xxx){ … } 中，只会调用该对象本身的属性，不会去尝试调用 对象隐式原型上的属性</p>
<p>判断一个对象属性是否为显示原型上，还是隐式原型上，使用 xxx.hasOwnProperty(xxx) 来判断</p>
</blockquote>
</li>
</ol>
<p>所有的函数(箭头函数除外)都有一个 prototype 属性(显式原型)，属性值为该对象的显示构造函数的原型</p>
<hr>
<p>忽略上面一段文字，重新用另外一段文字来描述原型规则：</p>
<ol>
<li><p>所有通过 function 创建的对象，都叫函数对象</p>
</li>
<li><p>所有函数对象都有一个原型对象 prototype</p>
</li>
<li><p>所有对象上都有一个隐式原型对象 <code>__proto__</code> ，指向创建该对象的构造函数的原型对象</p>
</li>
<li><p>所有的原型对象上都有一个 constructor 对象，指向该原型对象所在的构造函数本身</p>
<blockquote>
<p>JS 为了避免死循环，因此 Object.prototype 的值为 null</p>
</blockquote>
</li>
</ol>
<h3 id="写一个原型链继承的例子"><a href="#写一个原型链继承的例子" class="headerlink" title="写一个原型链继承的例子"></a>写一个原型链继承的例子</h3><p>对象显示原型对象是可以更改的！所谓继承就是 动态 更改指定构造函数的显式原型。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">function Animal()&#123;</span><br><span class="line">    this.eat = function ()&#123;</span><br><span class="line">        console.log(&#x27;eat...&#x27;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function Dog()&#123;</span><br><span class="line">    this.run = function () &#123;</span><br><span class="line">        console.log(&#x27;run...&#x27;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//将 Dog 的显性原型更改为一个 Animal 对象实例，从而让 Dog 也具有 Animal 的属性</span><br><span class="line">Dog.prototype = new Animal()</span><br><span class="line">const mydog = new Dog()</span><br><span class="line"></span><br><span class="line">mydog.eat()</span><br><span class="line">mydog.run()</span><br></pre></td></tr></table></figure>
<p>还有另外一种继承方式，即直接给 函数的 prototype 属性值添加新的属性：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">function Dog()&#123;</span><br><span class="line">    this.run = function () &#123;</span><br><span class="line">        console.log(&#x27;run...&#x27;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Dog.prototype.eat = function ()&#123;</span><br><span class="line">    console.log(&#x27;eat...&#x27;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const mydog = new Dog()</span><br><span class="line"></span><br><span class="line">console.log(Dog.prototype)</span><br><span class="line">console.log(mydog.__proto__)</span><br><span class="line"></span><br><span class="line">mydog.eat()</span><br><span class="line">mydog.run()</span><br></pre></td></tr></table></figure>
<h2 id="new-操作的实现过程"><a href="#new-操作的实现过程" class="headerlink" title="new 操作的实现过程"></a>new 操作的实现过程</h2><p>new 运算符创建一个用户定义的对象类型的实例，或具有构造函数的内置对象的实例。new 关键词会进行以下操作：</p>
<ol>
<li>创建一个空的简单对象(即 {})</li>
<li>链接该对象(即设置该对象的构造函数) 到另一个对象</li>
<li>将步骤1新创建的对象作为 this 的上下文</li>
<li>如果该函数没有返回对象，则返回 this</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function Person (str)&#123;</span><br><span class="line">    this.name = str</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const me = new Person(&#x27;puxiao&#x27;)</span><br></pre></td></tr></table></figure>
<p>以上面代码中 new 为例，分别对应上面 4 个环节：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">let obj = &#123;&#125;</span><br><span class="line">obj.__proto__ = Person.prototype</span><br><span class="line">Person.apply(obj,&#x27;puxiao&#x27;)</span><br><span class="line">return this</span><br><span class="line"></span><br><span class="line">let me = obj</span><br></pre></td></tr></table></figure>
<h2 id="闭包和作用域"><a href="#闭包和作用域" class="headerlink" title="闭包和作用域"></a>闭包和作用域</h2><p>JS 不是 静态编译型 语言，而是 动态解释型 语言。</p>
<h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h3><p>闭包是指有权访问另外一个函数作用域内变量的函数。</p>
<p>创建闭包的最常见方式就是在一个函数内创建另外一个函数。</p>
<h3 id="闭包的用途"><a href="#闭包的用途" class="headerlink" title="闭包的用途"></a>闭包的用途</h3><ol>
<li><p>使我们可以在函数外部访问到函数内部的变量。具体做法是 通过调用闭包函数，从而在外部访问到函数内部的变量，可以使用这种方法来创建私有变量。</p>
</li>
<li><p>使已经运行结束的函数上下文中的变量对象继续保留在内存中，因为闭包函数保留了这个变量对象的引用，所以这个变量才不会被回收。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function myFun()&#123;</span><br><span class="line">    let n = 0</span><br><span class="line">    function add()&#123;</span><br><span class="line">        n ++</span><br><span class="line">        console.log(n)</span><br><span class="line">    &#125;</span><br><span class="line">    return add</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const add = myFun()</span><br><span class="line"></span><br><span class="line">console.log(add()) // 1</span><br><span class="line">console.log(add()) // 2</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="声明提升"><a href="#声明提升" class="headerlink" title="声明提升"></a>声明提升</h3><p>使用 var、let、const 定义变量 或 function 定义函数，默认都会进行变量提升。</p>
<h3 id="执行上下文"><a href="#执行上下文" class="headerlink" title="执行上下文"></a>执行上下文</h3><p>JS 中执行上下文是可以改变的，存在以下 2 种情况：</p>
<ol>
<li>定义时的上下文</li>
<li>运行时的上下文</li>
</ol>
<h3 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h3><p>作用域：作用域是定义变量的区域，有一套访问变量的规则。分为全局作用域、函数作用域、ES6以后出现的块级作用域</p>
<p>在 ES6之前，JS 不存在块级作用域，在 ES6以后，可以使用 let 来定义块级作用域中的变量。</p>
<h3 id="作用域链"><a href="#作用域链" class="headerlink" title="作用域链"></a>作用域链</h3><p>当代码需要调用某个变量时，若当前作用域中不存在该变量，则会一级一级向外层作用域查找。</p>
<p>这种一级一级查找变量也就形成了一种 “链式结构”，这就是作用域链。</p>
<h3 id="函数的调用"><a href="#函数的调用" class="headerlink" title="函数的调用"></a>函数的调用</h3><p>JS 中函数调用有 4 种模式：</p>
<ol>
<li>方法调用</li>
<li>正常函数调用</li>
<li>构造函数调用</li>
<li>apply/call调用</li>
</ol>
<p>无论哪种函数调用，除了声明时定义的形参外，还会自动添加2个形参：this 和 arguments</p>
<h3 id="This"><a href="#This" class="headerlink" title="This"></a>This</h3><p>this 指向谁？</p>
<ol>
<li>在浏览器中，this 指向 windows 对象</li>
<li>在函数中，this 指向最后调用它的那个对象</li>
<li>在构造函数中，this 指向 new 出来的那个新对象</li>
<li>call/apply/bind 中的 this 指向被强行绑定的那个对象</li>
<li>箭头函数中的 this，指向父作用域中的 this</li>
</ol>
<p>上面前 4 种情况，this 只有在执行时才能确认值，定义时无法确认。唯独第 5 种情况，this 在定义时就已经被明确下来。</p>
<p>myFun.xx.call(xxx) 中，call(xxx) 可以将 myFun.xx 中的 this 对象修改为 xxx</p>
<p>apply/call 主要区别仅在 传递函数形参时的形式，apply 是用数组，而 call 使用 逗号分隔。</p>
<p>bind 则表示将作用域固定为某对象，但并不会让函数立即执行。</p>
<h3 id="闭包-1"><a href="#闭包-1" class="headerlink" title="闭包"></a>闭包</h3><p>闭包的应用场景：函数返回值依然是函数</p>
<h1 id="网络通信"><a href="#网络通信" class="headerlink" title="网络通信"></a>网络通信</h1><h2 id="异步和单线程"><a href="#异步和单线程" class="headerlink" title="异步和单线程"></a>异步和单线程</h2><p>所谓同步，就是会阻塞进程，当前不执行完毕不会执行后面代码。</p>
<p>所谓异步，就是不会阻塞进程。</p>
<p>通常情况下，需要 “等待” 的操作需求，都最好使用异步。</p>
<blockquote>
<p>例如 加载资源、请求数据、计时器等</p>
<p>alert() 是同步，会阻塞进程</p>
</blockquote>
<h2 id="跨域"><a href="#跨域" class="headerlink" title="跨域"></a>跨域</h2><h3 id="允许跨域的标签"><a href="#允许跨域的标签" class="headerlink" title="允许跨域的标签"></a>允许跨域的标签</h3><p>在网页中，有3个标签是可以允许跨域加载资源：</p>
<ol>
<li><code>&lt;img\&gt;</code></li>
<li><code>&lt;link\&gt;</code></li>
<li><code>&lt;script&gt;</code></li>
</ol>
<h3 id="JSONP"><a href="#JSONP" class="headerlink" title="JSONP"></a>JSONP</h3><p>所谓通过 JSONP 解决跨域，本质上就是利用了 <code>&lt;script&gt;</code> 标签允许跨域加载资源的特性 来实现跨域数据请求：</p>
<ol>
<li>客户端通过 <code>&lt;script src=&#39;xxxxx&#39;&gt;</code> 来请求 某网络 JS 文件地址</li>
<li>服务器 动态生成 对应的 JS 文件内容(包含客户端需要的数据)返回给客户端</li>
</ol>
<h3 id="服务器端设置允许跨域"><a href="#服务器端设置允许跨域" class="headerlink" title="服务器端设置允许跨域"></a>服务器端设置允许跨域</h3><p>服务端返回数据时，添加 允许跨域的 header 标签：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">respose.setHeader(&#x27;Access-Control-Allow-Origin&#x27;,&#x27;xxxxx&#x27;)</span><br></pre></td></tr></table></figure>
<h2 id="安全性"><a href="#安全性" class="headerlink" title="安全性"></a>安全性</h2><h3 id="XSS-跨站请求攻击"><a href="#XSS-跨站请求攻击" class="headerlink" title="XSS 跨站请求攻击"></a>XSS 跨站请求攻击</h3><p>提交数据内容中包含 <script\> 代码，若对方并没有处理，则对方代码中就会包含攻击方的 JS 脚本。</p>
<p>通常 JS 脚本可以获取 cookie 并发送到自己服务器中。</p>
<p>后端解决方案：将 &lt; 替换为 <code>&amp;lt;</code> 、&gt; 替换为 <code>&amp;gt;</code> 这样就不是 JS 代码可执行的片段代码了。</p>
<h3 id="XSRF-伪装请求"><a href="#XSRF-伪装请求" class="headerlink" title="XSRF 伪装请求"></a>XSRF 伪装请求</h3><p>假设某网站支付的接口中，并没有进行用户验证。那么攻击者可以将该请求地址 伪装 隐藏到 给你的特定邮件或网页中，当你点击请求包含该 请求连接接口地址时，则进行自动支付(假设支付接口并不进行二次验证)。</p>
<p>后端解决方案：增加验证流程即可</p>
<h2 id="http相关"><a href="#http相关" class="headerlink" title="http相关"></a>http相关</h2><h3 id="GET-与-POST-的区别"><a href="#GET-与-POST-的区别" class="headerlink" title="GET 与 POST 的区别"></a>GET 与 POST 的区别</h3><p>GET 数据位于 消息头中，而 POST 数据位于 消息体 中。</p>
<p>另外，POST 请求不可以做以下事情：</p>
<ol>
<li>POST 请求不会被缓存</li>
<li>POST 请求不会保留在浏览器历史记录中</li>
<li>POST 请求不能收藏为书签</li>
<li>POST 请求对数据长度没有要求限制</li>
</ol>
<h1 id="模块化开发"><a href="#模块化开发" class="headerlink" title="模块化开发"></a>模块化开发</h1><h3 id="模块化的理解"><a href="#模块化的理解" class="headerlink" title="模块化的理解"></a>模块化的理解</h3><p>一个模块是实现一个特定功能的一组方法，最常用的是立即执行函数的写法，通过利用闭包来实现变量的私有化，不会对全局造成污染。</p>
<h3 id="函数式编程简单介绍"><a href="#函数式编程简单介绍" class="headerlink" title="函数式编程简单介绍"></a>函数式编程简单介绍</h3><p>通过编写纯函数，避免共享状态、可变数据、副作用 来构建软件的过程。</p>
<p>面向对象中应用程序的状态通常和方法共享和共处，但函数式编程不是这样，因此函数式编程代码更简洁，更可预测，更容易测试。</p>
<h3 id="纯函数"><a href="#纯函数" class="headerlink" title="纯函数"></a>纯函数</h3><p>给固定的参数，返回结果也一定是固定值。</p>
<h3 id="高阶函数"><a href="#高阶函数" class="headerlink" title="高阶函数"></a>高阶函数</h3><p>将函数作为参数或者返回值的函数，称为高阶函数。</p>
<h1 id="手工实现系列"><a href="#手工实现系列" class="headerlink" title="手工实现系列"></a>手工实现系列</h1><h3 id="手工实现Array-prototype-map"><a href="#手工实现Array-prototype-map" class="headerlink" title="手工实现Array.prototype.map"></a>手工实现Array.prototype.map</h3><p><strong>分析：</strong></p>
<p>map() 函数本身作用是将数组中每一个元素都执行一遍某个函数，并将所有的执行结果汇总成一个新的数组。</p>
<p><strong>实现：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">function map(arr, callback) &#123;</span><br><span class="line">    if (!Array.isArray(arr) || !arr.length || typeof callback !== &#x27;function&#x27;) &#123;</span><br><span class="line">        return []</span><br><span class="line">    &#125;</span><br><span class="line">    const result = []</span><br><span class="line"></span><br><span class="line">    for (let i = 0; i &lt; arr.length; i++) &#123;</span><br><span class="line">        result.push(callback(arr[i], i, arr))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return result</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const arr = [0, 1, 2]</span><br><span class="line">function add(n, i, arr) &#123;</span><br><span class="line">    return n + 1</span><br><span class="line">&#125;</span><br><span class="line">let new_arr = map(arr, add)</span><br><span class="line">console.log(new_arr) //[1,2,3]</span><br></pre></td></tr></table></figure>
<h3 id="手工实现Array-prototype-filter"><a href="#手工实现Array-prototype-filter" class="headerlink" title="手工实现Array.prototype.filter"></a>手工实现Array.prototype.filter</h3><p><strong>分析：</strong></p>
<p>filter() 函数的作用是将数组中的所有元素都进行一次 某个函数 计算是否匹配，并将所有匹配的元素汇总成一个新数组并返回。</p>
<p><strong>实现：</strong></p>
<p>和上面 map() 的方法类似，唯一区别就在于 map 是 result.push(callback(arr[i],i,arr))，而 filter 应该是：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if(callback(arr[i],i,arr))&#123;</span><br><span class="line">  result.push(arr[i])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="手工实现Array-prototype-reduce"><a href="#手工实现Array-prototype-reduce" class="headerlink" title="手工实现Array.prototype.reduce"></a>手工实现Array.prototype.reduce</h3><p><strong>分析：</strong></p>
<p>reduce() 函数的作用是将数组中所有元素都执行一次 某个函数，并依次累加这些计算结果，将最终结果汇总为单个返回值。</p>
<p><strong>实现：</strong></p>
<p>和前面两个略有不同的地方在于 reduce() 函数有一个 初始值 的参数(不传该值则默认为空，不会加入到汇总的起始中)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">function reduce(arr, callback, initial) &#123;</span><br><span class="line">    if (!Array.isArray(arr) || !arr.length || typeof callback !== &#x27;function&#x27;) &#123;</span><br><span class="line">        return []</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    let boo = initial !== undefined</span><br><span class="line">    let result = boo ? initial : arr[0]</span><br><span class="line"></span><br><span class="line">    for (let i = boo ? 1 : 0; i &lt; arr.length; i++) &#123;</span><br><span class="line">        result = callback(result, arr[i], i, arr)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return result</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const arr = [0, 1, 2]</span><br><span class="line">function callbackFun(value, item, i, arr) &#123;</span><br><span class="line">    return value += item</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let value = reduce(arr, callbackFun)</span><br><span class="line">let value2 = reduce(arr, callbackFun, 2)</span><br><span class="line">console.log(value, value2) // 3,5</span><br></pre></td></tr></table></figure>
<h3 id="手写一个深度拷贝"><a href="#手写一个深度拷贝" class="headerlink" title="手写一个深度拷贝"></a>手写一个深度拷贝</h3><p>先说一下浅拷贝：浅拷贝的原则是：</p>
<ol>
<li>若属性为值类型，则直接赋值</li>
<li>若属性为引用类型，则添加引用(仅仅是添加指针，内存中并未增加新的存储实体)</li>
</ol>
<p><strong>第1种浅拷贝：</strong></p>
<p>对于对象来说，比较简单的浅拷贝方式就是：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let b = &#123;...a&#125;</span><br></pre></td></tr></table></figure>
<p>对于组来说，：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let b = [...a]</span><br></pre></td></tr></table></figure>
<p><strong>第2种浅拷贝：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let b = Object.assign(&#123;&#125;,a)</span><br></pre></td></tr></table></figure>
<p>注意：Object.assign() 仅仅可以实现第一层的拷贝，如果嵌套多层则还是引用而非深度拷贝。</p>
<p><strong>深拷贝</strong></p>
<p>深拷贝就是在内存中，完全新建一份存储实体对象。</p>
<p>深拷贝实现思路为：</p>
<ol>
<li>判断拷贝对象的类型，若为值类型，则直接赋值</li>
<li>若为引用类型，则通过递归，深层次对属性进行查询，直到属性的值为值类型后，赋值，逐层赋值。</li>
</ol>
<p><strong>简单的实现代码：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">function deepClone(target) &#123;</span><br><span class="line">    let result = undefined</span><br><span class="line"></span><br><span class="line">    if (target === null || !(typeof target === &#x27;object&#x27;)) &#123;</span><br><span class="line">        result = target</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        result = target.constructor.name === &#x27;Array&#x27; ? [] : &#123;&#125;</span><br><span class="line">        for (let key in target) &#123;</span><br><span class="line">            result[key] = deepClone(target[key])</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>在最新的 JS for in 中，本身就只会循环 对象自身特有的属性，因此是不需要添加 target.hasOwnProperty(key) 判断该属性是自身属性还是原型对象的属性。</p>
</blockquote>
<h2 id="防抖与节流"><a href="#防抖与节流" class="headerlink" title="防抖与节流"></a>防抖与节流</h2><h3 id="防抖："><a href="#防抖：" class="headerlink" title="防抖："></a>防抖：</h3><p>防抖 指 在 事件被触发 N 秒后再执行回调函数，如果在这 N 秒内又被触发，则重新计时。</p>
<blockquote>
<p>例如在用户信息提交时，可以避免用户多次点击向后台多次提交</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function debounce(fun,wait)&#123;</span><br><span class="line">  let timer </span><br><span class="line">  return (...args) =&gt; &#123;</span><br><span class="line">    clearTimeout(time)</span><br><span class="line">    timer = setTimeout(() =&gt; &#123;</span><br><span class="line">      fun(...args)</span><br><span class="line">    &#125;, wait)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="节流："><a href="#节流：" class="headerlink" title="节流："></a>节流：</h3><p>节流 指 在 N 秒之内，无论调用多少次，函数都只执行1次。</p>
<blockquote>
<p>例如在滚动浏览器时，scroll 函数的事件监听上，通过节流降低事件调用的频率</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function throttle(fun,wait)&#123;</span><br><span class="line">  let timer</span><br><span class="line">  return (...args) =&gt; &#123;</span><br><span class="line">    if(timer)&#123;</span><br><span class="line">      return</span><br><span class="line">    &#125;</span><br><span class="line">    timer = setTimerout(() =&gt; &#123;</span><br><span class="line">      fun(...args)</span><br><span class="line">      timer = null</span><br><span class="line">    &#125;, wait)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="函数式编程"><a href="#函数式编程" class="headerlink" title="函数式编程"></a>函数式编程</h1><h2 id="什么是函数式编程？"><a href="#什么是函数式编程？" class="headerlink" title="什么是函数式编程？"></a>什么是函数式编程？</h2><p>函数式编程是一种编程范式，<strong>主要利用函数把运算过程封装起来，通过组合各种函数来计算结果</strong>。</p>
<p><strong>试想一下以下场景：</strong></p>
<p>将字符串 “hello yang puxiao” 变成每个单词(拼音) 首字母大写。</p>
<p>代码一：按照正常的运算过程，代码为</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let str = &#x27;hello yang puxiao&#x27;</span><br><span class="line">let arr = str.split(&#x27; &#x27;) //先用空格将字符串每个单词断开，将单词组合成一个数组</span><br><span class="line">arr = arr.map(item =&gt; item.slice(0,1).toUpperCase() + item.slice(1)) //得到新的数组元素</span><br><span class="line">str = arr.join(&#x27; &#x27;) //将数组元素以空格重新分割，得到最终目标结果</span><br></pre></td></tr></table></figure>
<p>代码二：上面代码可以简写合并为以下代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let str = &#x27;hello yang puxiao&#x27;</span><br><span class="line">str = str.split(&#x27; &#x27;)</span><br><span class="line">    .map(item =&gt; item.slice(0,1).toUpperCase() + item.slice(1))</span><br><span class="line">    .join(&#x27; &#x27;)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>观察并留意以上 2 种方式的代码，这里先不讨论 代码一，而是去讲一下代码二。</p>
</blockquote>
<p><strong>先说结论：代码二 实际上执行的就是 函数式编程思想。</strong></p>
<p>代码二实际上执行流程是：join( map( split( str ) ) )，体现了函数式编程的核心思想：通过函数对数据进行转换。</p>
<p><strong>函数式编程的两个基本特点：</strong></p>
<ol>
<li>通过函数来对数据进行转换</li>
<li>通过串联多个函数来求结果</li>
</ol>
<h2 id="对比声明式与命令式"><a href="#对比声明式与命令式" class="headerlink" title="对比声明式与命令式"></a>对比声明式与命令式</h2><p><strong>命令式：</strong> 通过编写一条又一条的指令去计算执行一些动作。通常会涉及一些复杂的细节和语句，例如 for、if、switch、throw</p>
<p><strong>声明式：</strong> 通过写表达式的方式来声明我们想干什么，而不是通过一步一步的指示。表达式通常是某些函数调用的复合，一些值和操作符，用来计算出结果值。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//命令式</span><br><span class="line">const team = [&#123;ceo:&#x27;a&#x27;&#125;,&#123;ceo:&#x27;b&#x27;&#125;,&#123;ceo:&#x27;c&#x27;&#125;]</span><br><span class="line">const ceo = []</span><br><span class="line">for(let i = 0; i&lt; team.length; i++)&#123;</span><br><span class="line">    ceo.push(team[i].ceo)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//声明式</span><br><span class="line">const team = const team = [&#123;ceo:&#x27;a&#x27;&#125;,&#123;ceo:&#x27;b&#x27;&#125;,&#123;ceo:&#x27;c&#x27;&#125;]</span><br><span class="line">const ceo = team.map(item =&gt; item.ceo)</span><br></pre></td></tr></table></figure>
<p>从上面代码对比中，可以看到，命令式更加强调执行过程中的每一个细节。而声明式则仅为一个表达式，不关心计数器迭代过程、不关心返回的数组如何收集。</p>
<p><strong>命令式强调的是：每一步怎么做，并且每一个步骤都会记录中间结果，方便调试</strong></p>
<p><strong>声明式强调的是：做什么，但不过分关注直接过程</strong></p>
<h2 id="函数式编程与声明式编程的关系"><a href="#函数式编程与声明式编程的关系" class="headerlink" title="函数式编程与声明式编程的关系"></a>函数式编程与声明式编程的关系</h2><p>函数式编程就是声明式编程中的一种。</p>
<p>函数式编程主要思想是将计算机运算看作函数的计算。也就是把程序问题抽象成数学问题去解决。</p>
<p>函数式编程中，所有的变量都是唯一的值，就像是数学中的代数 x y，他们要么还未被解出，要么是被解出的固定值。对于 x = x +1 这种自增是不合法的，因为修改了代数值，不符合数学逻辑。</p>
<p>严格意义上讲，函数式编程中不可以出现 if、switch 等控制语句，如果需要条件判断可使用三元运算符。</p>
<h2 id="一些名词解释"><a href="#一些名词解释" class="headerlink" title="一些名词解释"></a>一些名词解释</h2><h4 id="纯函数-无副作用"><a href="#纯函数-无副作用" class="headerlink" title="纯函数(无副作用)"></a>纯函数(无副作用)</h4><p>无副作用指调用函数时不会修改外部状态，即一个函数调用 N 次后依然返回相同的结果。通常把这种无副作用的函数称为 纯函数。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">let num = 0</span><br><span class="line"></span><br><span class="line">//每次执行 add()，都会修改外部的 num 的值，因此 add() 函数不是纯函数，他是有副作用的</span><br><span class="line">function add()&#123;</span><br><span class="line">  num ++</span><br><span class="line">  return num</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//每次执行 add2()，函数内部执行的是将参数 num + 1 并返回该值，并没有修改外部任何对象</span><br><span class="line">//无论执行多少次 add2()，只要保证所传入的 参数一致，其返回结果也一定相同</span><br><span class="line">//因此这里的 add2() 是纯函数，且无副作用。</span><br><span class="line">function add2(num) &#123;</span><br><span class="line">  return num + 1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="透明引用"><a href="#透明引用" class="headerlink" title="透明引用"></a>透明引用</h4><p>透明引用指函数只会用到传递给他的变量(参数)以及内部创建的变量，不会使用到其他变量。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">let a = 1</span><br><span class="line">let b = 2</span><br><span class="line"></span><br><span class="line">//add() 函数内部使用到了本不是自己内部定义，也不是传递进来的参数的变量</span><br><span class="line">function add()&#123;</span><br><span class="line">  return a + b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//add2() 函数内部仅使用到了内部定义或参数变量，没有用到其他变量</span><br><span class="line">function add2(a,b)&#123;</span><br><span class="line">  return a + b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>函数式编程采用透明引用，除了参数外，内部不引用其他外部变量。</p>
<h4 id="不可变变量"><a href="#不可变变量" class="headerlink" title="不可变变量"></a>不可变变量</h4><p>不可变变量指变量一旦创建后，就不能再进行修改。任何修改都会生成一个新的变量。</p>
<p>换句话说：不可以修改变量，但可以返回新的值。</p>
<h4 id="函数是一等公民"><a href="#函数是一等公民" class="headerlink" title="函数是一等公民"></a>函数是一等公民</h4><p>这是一个比喻，所谓一等公民，不是指函数最厉害，而是指 <strong>函数和其他一等公民一样(变量)</strong>，可以赋值给其他变量，也可以作为参数，或者作为函数返回值。</p>
<h3 id="补充说明：不可变变量-和-JS-中-const-的概念和用途完全不同"><a href="#补充说明：不可变变量-和-JS-中-const-的概念和用途完全不同" class="headerlink" title="补充说明：不可变变量 和 JS 中 const 的概念和用途完全不同"></a>补充说明：不可变变量 和 JS 中 const 的概念和用途完全不同</h3><p><strong>虽然本小节讲的是 函数式编程，但是这里插入一些 Object.freeze() 的知识，尽管和本小节并无任何关联。</strong></p>
<p>注意：const 关键词声明的变量，仅仅表示类型不可变，类型的某属性值是可以修改的。</p>
<p>因此使用 const 声明变量并不能满足 不可变变量 的要求。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const obj = &#123; age: 18 &#125;</span><br><span class="line">obj.age = 34</span><br><span class="line">console.log(obj.age) // 34</span><br></pre></td></tr></table></figure>
<p>在 ES6 之前，原生 JS 不支持不可变变量，需要使用第三方库来实现，例如 Immutable.js、Mori 等。</p>
<p>在 ES6 之后，通过新增的 Object.freeze() 来冻结一个对象，来实现 不可变变量。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const obj = Object.freeze(&#123; age: 18 &#125;)</span><br><span class="line">obj.age = 34 //在JS严格模式下，此时会抛出一个 TypeError 错误</span><br><span class="line">console.log(obj.age) //18</span><br></pre></td></tr></table></figure>
<p>通常情况下，不可变变量 会应用在 配置项中，这样避免其他地方无意修改配置项。</p>
<p><strong>使用 Object.freeze() 冻结对象的补充说明：</strong></p>
<p><strong>补充1：冻结对象后</strong></p>
<ol>
<li>不能添加新属性</li>
<li>不能删除已有新属性</li>
<li>不能修改已有属性的值</li>
<li>不能修改原型</li>
<li>不能修改已有属性的可枚举新、可配置性、可写性</li>
</ol>
<p><strong>补充2：默认只冻结对象第一层属性</strong></p>
<p>若对象某属性依然为一个对象，则第二层对象属性值是不受约束，是可以修改的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let me = Object.freeze(&#123;age:18,do:&#123;react:&#x27;React&#x27;&#125;&#125;)</span><br><span class="line">me.do.react = &#x27;Taro&#x27;</span><br><span class="line">console.log(me.do.react) // Taro</span><br></pre></td></tr></table></figure>
<p><strong>补充3：属性访问器 getter 和 setter 不受影响</strong></p>
<p>假设该对象具有属性访问器 getter 和  setter，那么他们作为函数本身也是会被 冻结，无法再修改的，但由于它们是函数，且可以通过参数修改属性值，所以会给人错觉，以为还是可以修改属性值的。</p>
<p><strong>补充4：若数组被冻结，则无法向该数组增加或删除数组元素</strong></p>
<p><strong>补充5：通过递归，深层冻结</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function deepFreeze(obj)&#123;</span><br><span class="line">    for( let key in obj)&#123;</span><br><span class="line">        if(obj[key] !==null &amp;&amp; typeof obj[key] === &#x27;object&#x27;)&#123;</span><br><span class="line">            deepFreeze(obj[key])</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return Object.freeze(obj)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const me = deepFreeze(&#123;age:18,do:&#123;react:&#x27;React&#x27;&#125;&#125;)</span><br><span class="line">me.do.react = &#x27;Taro&#x27; //在严格模式下，会报 TypeError 错误</span><br><span class="line">console.log(me) //React</span><br></pre></td></tr></table></figure>
<p><strong>补充6：若使用 let 创建变量，尽管引用对象可以被冻结无法修改，但可以对变量重新赋值</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//若使用 let 来定义变量</span><br><span class="line">let me = Object.freeze(&#123;age:18&#125;)</span><br><span class="line"></span><br><span class="line">me = &#123;age:34&#125; //直接将变量重新赋值</span><br><span class="line">console.log(me.age) //34</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//若使用 const 来定义变量</span><br><span class="line">const me = Object.freeze(&#123;age:18&#125;)</span><br><span class="line"></span><br><span class="line">me = &#123;age:34&#125; //尝试将变量重新赋值，会直接报错</span><br></pre></td></tr></table></figure>
<h4 id="自由变量"><a href="#自由变量" class="headerlink" title="自由变量"></a>自由变量</h4><p>自由变量指不属于函数作用域的变量，通常情况下是指外层函数内定义的变量。</p>
<blockquote>
<p>所有全局变量都是自由变量，严格来说引用了全局变量的函数都是闭包，但这种闭包并没有什么实际意义作用，通常情况下自由变量是指 闭包 中外层函数中定义的变量。</p>
</blockquote>
<h2 id="常见的函数式编程模型"><a href="#常见的函数式编程模型" class="headerlink" title="常见的函数式编程模型"></a>常见的函数式编程模型</h2><h3 id="1、闭包"><a href="#1、闭包" class="headerlink" title="1、闭包"></a>1、闭包</h3><p>闭包的形成条件：</p>
<ol>
<li>函数内创建函数，即存在 内、外 两层函数</li>
<li>内层函数中引用了外层函数中定义的局部变量</li>
</ol>
<p>闭包的用途：可以定义写作用域局限的持久化变量，这些变量可以用来做缓存或者计算中间量等。</p>
<blockquote>
<p>简单来说，就是通过闭包，可以将函数内定义的变量持久化</p>
</blockquote>
<p>闭包将局部变量持久化的代码示例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">//通过匿名函数，创建了一个闭包</span><br><span class="line">const cache = (function()&#123;</span><br><span class="line">  const store = &#123;&#125;</span><br><span class="line">  return &#123;</span><br><span class="line">    get(key)&#123;</span><br><span class="line">    return store[key]</span><br><span class="line">  &#125;</span><br><span class="line">  set(key,val)&#123;</span><br><span class="line">    store[key]=val</span><br><span class="line">  &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;())</span><br><span class="line"></span><br><span class="line">cache.set(&#x27;num&#x27;:1)</span><br><span class="line">cache.get(&#x27;num&#x27;) //1</span><br></pre></td></tr></table></figure>
<p>请注意：上述代码中，通过创建闭包，持久化了一个局部变量 sotre，弊端是 sotre 持续占用内存空间，永远不会被正常释放(垃圾回收)，容易造成内存浪费，所以一般需要一些额外手动的清理机制。</p>
<h3 id="2、高阶函数"><a href="#2、高阶函数" class="headerlink" title="2、高阶函数"></a>2、高阶函数</h3><p>高阶函数：指一个函数以函数为参数，或以函数为返回值，再或者即以函数为参数同时返回值也是一个函数。</p>
<p>高阶函数常见用途：</p>
<ol>
<li>抽象或隔离行为、作用、异步控制流程作为回调函数</li>
<li>创建可以泛用于各种数据类型的功能</li>
<li>部分应用于函数参数，或 创建一个柯里化的函数</li>
<li>接收一个函数列表，并返回一些由这个列表中的函数组成的复合函数</li>
</ol>
<blockquote>
<p>以上 4 条总结摘抄于 网上相关教程，本人暂时不太完全理解。</p>
</blockquote>
<p>使用高阶函数会让我们的代码更加清晰简洁。例如 Array.prototype.map 就是高阶函数。</p>
<h3 id="3、函数柯里化"><a href="#3、函数柯里化" class="headerlink" title="3、函数柯里化"></a>3、函数柯里化</h3><p>柯里化又称部分求值，柯里化函数会接收一些参数，然后不会立即求值，而是继续返回一个新函数，将传入的参数通过闭包的形式保存，等到被真正求值的时候，再一次性把所有传入的参数进行求值。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//普通函数</span><br><span class="line">function add(x,y)&#123;</span><br><span class="line">  return x + y</span><br><span class="line">&#125;</span><br><span class="line">add(1,2) //3</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//柯里化函数</span><br><span class="line">const add = function(x) &#123;</span><br><span class="line">  return function (y) &#123;</span><br><span class="line">    return x + y</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">let increment = add(1)</span><br><span class="line">imcrement(2) //3</span><br></pre></td></tr></table></figure>
<p>以上代码还可以简化为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//柯里化函数</span><br><span class="line">const add = function(x) &#123;</span><br><span class="line">  return function (y) &#123;</span><br><span class="line">    return x + y</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let result = add(1)(2)</span><br><span class="line">console.log(result) //3</span><br></pre></td></tr></table></figure>
<p>柯里化通过传递较少的参数，得到一个已经记住了这些参数的新函数，某种意义上讲，这是一种对参数的 “缓存”，是一个高效的编写函数的方法。</p>
<blockquote>
<p>依我目前的理解，柯里化本质上是运用了 JS 中函数参数数量不做严格限制的前提下进行的，我认为在 TypeScript 环境下，不太适合做柯里化。</p>
</blockquote>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined" rel="external nofollow noreferrer">freelaeder</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="https://freelaeder.github.io/archives/dc3acdcc.html">https://freelaeder.github.io/archives/dc3acdcc.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a target="_blank" rel="noopener external nofollow noreferrer" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/js/">js</a><a class="post-meta__tags" href="/tags/JavaScript%E9%9D%A2%E8%AF%95%E5%9F%BA%E7%A1%80%E7%90%86%E8%AE%BA/">JavaScript面试基础理论</a></div><div class="post_share"><div class="social-share" data-image="/img/wallseven/wallseven10.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/archives/cf2f5248.html"><img class="prev-cover" src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/img/wallseven/wallseven22.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">Previous Post</div><div class="prev_info">如何设置文章置顶</div></div></a></div><div class="next-post pull-right"><a href="/archives/39a5927a.html"><img class="next-cover" src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/img/wallseven/wallseven9.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">Next Post</div><div class="next_info">gametime</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span> Related Articles</span></div><div class="relatedPosts-list"><div><a href="/archives/42b82995.html" title="Es6"><img class="cover" src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://s1.ax1x.com/2022/05/20/OOIVqx.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-07-02</div><div class="title">Es6</div></div></a></div><div><a href="/archives/37919ccb.html" title="data_type"><img class="cover" src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/img/picfive/wallfive%20(10).png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-06-16</div><div class="title">data_type</div></div></a></div><div><a href="/archives/1be48ee.html" title="debounce_throttle"><img class="cover" src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/img/picfive/wallfive%20(11).png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-06-16</div><div class="title">debounce_throttle</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> Comment</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="card-info-avatar is-center"><img class="avatar-img" src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/img/header.svg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/><div class="author-info__name">freelaeder</div><div class="author-info__description">我打碎了夕阳,散做漫天的星光</div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">93</div></a></div><div class="card-info-data-item is-center"><a href="/tags/"><div class="headline">Tags</div><div class="length-num">97</div></a></div><div class="card-info-data-item is-center"><a href="/categories/"><div class="headline">Categories</div><div class="length-num">15</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>Announcement</span></div><div class="announcement_content">你我裹挟韶光 , 流沔星河万丈</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Catalog</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#JavaScript%E9%9D%A2%E8%AF%95%E5%9F%BA%E7%A1%80%E7%90%86%E8%AE%BA"><span class="toc-number">1.</span> <span class="toc-text">JavaScript面试基础理论</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9B%AE%E5%BD%95"><span class="toc-number">1.1.</span> <span class="toc-text">目录</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%98%E9%87%8F%E7%B1%BB%E5%9E%8B%E5%92%8C%E8%AE%A1%E7%AE%97"><span class="toc-number">1.2.</span> <span class="toc-text">变量类型和计算</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%98%E9%87%8F%E7%B1%BB%E5%9E%8B%EF%BC%9A%E5%80%BC%E7%B1%BB%E5%9E%8B-%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.2.1.</span> <span class="toc-text">变量类型：值类型 + 引用类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%98%E5%82%A8%E6%96%B9%E5%BC%8F"><span class="toc-number">1.2.2.</span> <span class="toc-text">存储方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#typeof%EF%BC%9A%E6%9C%89-8-%E7%A7%8D%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.2.3.</span> <span class="toc-text">typeof：有 8 种类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%98%E9%87%8F%E8%AE%A1%E7%AE%97"><span class="toc-number">1.2.4.</span> <span class="toc-text">变量计算</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JS%E5%86%85%E7%BD%AE%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%B1%BB%E5%9E%8B%EF%BC%9A%E4%B8%80%E5%85%B1-10-%E7%A7%8D"><span class="toc-number">1.2.5.</span> <span class="toc-text">JS内置构造函数类型：一共 10 种</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#undefined%E4%B8%8Eundeclared%E3%80%81null%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.2.6.</span> <span class="toc-text">undefined与undeclared、null的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%92%8C-%E7%9A%84valueOf%E5%92%8CtoString%E7%9A%84%E7%BB%93%E6%9E%9C%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">1.2.7.</span> <span class="toc-text">{}和[]的valueOf和toString的结果是什么</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97"><span class="toc-number">1.2.8.</span> <span class="toc-text">赋值运算</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8E%9F%E5%9E%8B%E5%92%8C%E5%8E%9F%E5%9E%8B%E9%93%BE"><span class="toc-number">1.3.</span> <span class="toc-text">原型和原型链</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%95%E4%B8%BA%E5%8E%9F%E5%9E%8B"><span class="toc-number">1.3.1.</span> <span class="toc-text">何为原型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8E%9F%E5%9E%8B%E8%A7%84%E5%88%99"><span class="toc-number">1.3.2.</span> <span class="toc-text">原型规则</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%99%E4%B8%80%E4%B8%AA%E5%8E%9F%E5%9E%8B%E9%93%BE%E7%BB%A7%E6%89%BF%E7%9A%84%E4%BE%8B%E5%AD%90"><span class="toc-number">1.3.3.</span> <span class="toc-text">写一个原型链继承的例子</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#new-%E6%93%8D%E4%BD%9C%E7%9A%84%E5%AE%9E%E7%8E%B0%E8%BF%87%E7%A8%8B"><span class="toc-number">1.4.</span> <span class="toc-text">new 操作的实现过程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%97%AD%E5%8C%85%E5%92%8C%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="toc-number">1.5.</span> <span class="toc-text">闭包和作用域</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%97%AD%E5%8C%85"><span class="toc-number">1.5.1.</span> <span class="toc-text">闭包</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%97%AD%E5%8C%85%E7%9A%84%E7%94%A8%E9%80%94"><span class="toc-number">1.5.2.</span> <span class="toc-text">闭包的用途</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A3%B0%E6%98%8E%E6%8F%90%E5%8D%87"><span class="toc-number">1.5.3.</span> <span class="toc-text">声明提升</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87"><span class="toc-number">1.5.4.</span> <span class="toc-text">执行上下文</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="toc-number">1.5.5.</span> <span class="toc-text">作用域</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE"><span class="toc-number">1.5.6.</span> <span class="toc-text">作用域链</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E7%9A%84%E8%B0%83%E7%94%A8"><span class="toc-number">1.5.7.</span> <span class="toc-text">函数的调用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#This"><span class="toc-number">1.5.8.</span> <span class="toc-text">This</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%97%AD%E5%8C%85-1"><span class="toc-number">1.5.9.</span> <span class="toc-text">闭包</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1"><span class="toc-number">2.</span> <span class="toc-text">网络通信</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%82%E6%AD%A5%E5%92%8C%E5%8D%95%E7%BA%BF%E7%A8%8B"><span class="toc-number">2.1.</span> <span class="toc-text">异步和单线程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B7%A8%E5%9F%9F"><span class="toc-number">2.2.</span> <span class="toc-text">跨域</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%81%E8%AE%B8%E8%B7%A8%E5%9F%9F%E7%9A%84%E6%A0%87%E7%AD%BE"><span class="toc-number">2.2.1.</span> <span class="toc-text">允许跨域的标签</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JSONP"><span class="toc-number">2.2.2.</span> <span class="toc-text">JSONP</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF%E8%AE%BE%E7%BD%AE%E5%85%81%E8%AE%B8%E8%B7%A8%E5%9F%9F"><span class="toc-number">2.2.3.</span> <span class="toc-text">服务器端设置允许跨域</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%89%E5%85%A8%E6%80%A7"><span class="toc-number">2.3.</span> <span class="toc-text">安全性</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#XSS-%E8%B7%A8%E7%AB%99%E8%AF%B7%E6%B1%82%E6%94%BB%E5%87%BB"><span class="toc-number">2.3.1.</span> <span class="toc-text">XSS 跨站请求攻击</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#XSRF-%E4%BC%AA%E8%A3%85%E8%AF%B7%E6%B1%82"><span class="toc-number">2.3.2.</span> <span class="toc-text">XSRF 伪装请求</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#http%E7%9B%B8%E5%85%B3"><span class="toc-number">2.4.</span> <span class="toc-text">http相关</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#GET-%E4%B8%8E-POST-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">2.4.1.</span> <span class="toc-text">GET 与 POST 的区别</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%A8%A1%E5%9D%97%E5%8C%96%E5%BC%80%E5%8F%91"><span class="toc-number">3.</span> <span class="toc-text">模块化开发</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A8%A1%E5%9D%97%E5%8C%96%E7%9A%84%E7%90%86%E8%A7%A3"><span class="toc-number">3.0.1.</span> <span class="toc-text">模块化的理解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D"><span class="toc-number">3.0.2.</span> <span class="toc-text">函数式编程简单介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%AF%E5%87%BD%E6%95%B0"><span class="toc-number">3.0.3.</span> <span class="toc-text">纯函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0"><span class="toc-number">3.0.4.</span> <span class="toc-text">高阶函数</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%89%8B%E5%B7%A5%E5%AE%9E%E7%8E%B0%E7%B3%BB%E5%88%97"><span class="toc-number">4.</span> <span class="toc-text">手工实现系列</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%8B%E5%B7%A5%E5%AE%9E%E7%8E%B0Array-prototype-map"><span class="toc-number">4.0.1.</span> <span class="toc-text">手工实现Array.prototype.map</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%8B%E5%B7%A5%E5%AE%9E%E7%8E%B0Array-prototype-filter"><span class="toc-number">4.0.2.</span> <span class="toc-text">手工实现Array.prototype.filter</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%8B%E5%B7%A5%E5%AE%9E%E7%8E%B0Array-prototype-reduce"><span class="toc-number">4.0.3.</span> <span class="toc-text">手工实现Array.prototype.reduce</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%8B%E5%86%99%E4%B8%80%E4%B8%AA%E6%B7%B1%E5%BA%A6%E6%8B%B7%E8%B4%9D"><span class="toc-number">4.0.4.</span> <span class="toc-text">手写一个深度拷贝</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%98%B2%E6%8A%96%E4%B8%8E%E8%8A%82%E6%B5%81"><span class="toc-number">4.1.</span> <span class="toc-text">防抖与节流</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%98%B2%E6%8A%96%EF%BC%9A"><span class="toc-number">4.1.1.</span> <span class="toc-text">防抖：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%8A%82%E6%B5%81%EF%BC%9A"><span class="toc-number">4.1.2.</span> <span class="toc-text">节流：</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B"><span class="toc-number">5.</span> <span class="toc-text">函数式编程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%EF%BC%9F"><span class="toc-number">5.1.</span> <span class="toc-text">什么是函数式编程？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%B9%E6%AF%94%E5%A3%B0%E6%98%8E%E5%BC%8F%E4%B8%8E%E5%91%BD%E4%BB%A4%E5%BC%8F"><span class="toc-number">5.2.</span> <span class="toc-text">对比声明式与命令式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%E4%B8%8E%E5%A3%B0%E6%98%8E%E5%BC%8F%E7%BC%96%E7%A8%8B%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="toc-number">5.3.</span> <span class="toc-text">函数式编程与声明式编程的关系</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E4%BA%9B%E5%90%8D%E8%AF%8D%E8%A7%A3%E9%87%8A"><span class="toc-number">5.4.</span> <span class="toc-text">一些名词解释</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%AF%E5%87%BD%E6%95%B0-%E6%97%A0%E5%89%AF%E4%BD%9C%E7%94%A8"><span class="toc-number">5.4.0.1.</span> <span class="toc-text">纯函数(无副作用)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%8F%E6%98%8E%E5%BC%95%E7%94%A8"><span class="toc-number">5.4.0.2.</span> <span class="toc-text">透明引用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%8D%E5%8F%AF%E5%8F%98%E5%8F%98%E9%87%8F"><span class="toc-number">5.4.0.3.</span> <span class="toc-text">不可变变量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E6%98%AF%E4%B8%80%E7%AD%89%E5%85%AC%E6%B0%91"><span class="toc-number">5.4.0.4.</span> <span class="toc-text">函数是一等公民</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A1%A5%E5%85%85%E8%AF%B4%E6%98%8E%EF%BC%9A%E4%B8%8D%E5%8F%AF%E5%8F%98%E5%8F%98%E9%87%8F-%E5%92%8C-JS-%E4%B8%AD-const-%E7%9A%84%E6%A6%82%E5%BF%B5%E5%92%8C%E7%94%A8%E9%80%94%E5%AE%8C%E5%85%A8%E4%B8%8D%E5%90%8C"><span class="toc-number">5.4.1.</span> <span class="toc-text">补充说明：不可变变量 和 JS 中 const 的概念和用途完全不同</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%87%AA%E7%94%B1%E5%8F%98%E9%87%8F"><span class="toc-number">5.4.1.1.</span> <span class="toc-text">自由变量</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E7%9A%84%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%E6%A8%A1%E5%9E%8B"><span class="toc-number">5.5.</span> <span class="toc-text">常见的函数式编程模型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E3%80%81%E9%97%AD%E5%8C%85"><span class="toc-number">5.5.1.</span> <span class="toc-text">1、闭包</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2%E3%80%81%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0"><span class="toc-number">5.5.2.</span> <span class="toc-text">2、高阶函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3%E3%80%81%E5%87%BD%E6%95%B0%E6%9F%AF%E9%87%8C%E5%8C%96"><span class="toc-number">5.5.3.</span> <span class="toc-text">3、函数柯里化</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>Recent Post</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/archives/36044e1a.html" title="Dynamic list"><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="https://s1.ax1x.com/2022/05/20/OOImdK.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Dynamic list"/></a><div class="content"><a class="title" href="/archives/36044e1a.html" title="Dynamic list">Dynamic list</a><time datetime="2023-03-27T02:31:00.000Z" title="Created 2023-03-27 10:31:00">2023-03-27</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/archives/ae4c07b8.html" title="typeScript基础知识"><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/img/wallseven/wallseven27.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="typeScript基础知识"/></a><div class="content"><a class="title" href="/archives/ae4c07b8.html" title="typeScript基础知识">typeScript基础知识</a><time datetime="2022-07-01T01:53:00.000Z" title="Created 2022-07-01 09:53:00">2022-07-01</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/archives/77971af0.html" title="ts报错解决持续更新"><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/img/wallseven/wallseven26.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="ts报错解决持续更新"/></a><div class="content"><a class="title" href="/archives/77971af0.html" title="ts报错解决持续更新">ts报错解决持续更新</a><time datetime="2022-07-01T01:53:00.000Z" title="Created 2022-07-01 09:53:00">2022-07-01</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/archives/e6437fbd.html" title="uniapp实现返回顶部"><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/img/wallseven/wallseven25.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="uniapp实现返回顶部"/></a><div class="content"><a class="title" href="/archives/e6437fbd.html" title="uniapp实现返回顶部">uniapp实现返回顶部</a><time datetime="2022-06-29T03:53:00.000Z" title="Created 2022-06-29 11:53:00">2022-06-29</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/archives/33b9c85e.html" title="hooks使用"><img src= "data:image/gif;base64,R0lGODdhAQABAPAAAMPDwwAAACwAAAAAAQABAAACAkQBADs=" data-lazy-src="/img/wallseven/wallseven24.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="hooks使用"/></a><div class="content"><a class="title" href="/archives/33b9c85e.html" title="hooks使用">hooks使用</a><time datetime="2022-06-27T13:53:00.000Z" title="Created 2022-06-27 21:53:00">2022-06-27</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By freelaeder</div><div class="framework-info"><span>Framework </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Read Mode"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="Switch Between Light And Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle between single-column and double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="Setting"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table Of Contents"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="Scroll To Comments"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="Back To Top"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><div class="search-dialog__title" id="local-search-title">Local search</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="Search for Posts" type="text"/></div></div></div><hr/><div id="local-search-results"></div><span class="search-close-button"><i class="fas fa-times"></i></span></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/medium-zoom/dist/medium-zoom.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><script src="/js/search/local-search.js"></script><script>var preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',preloader.endLoading())</script><div class="js-pjax"><script>function loadValine () {
  function initValine () {
    const valine = new Valine(Object.assign({
      el: '#vcomment',
      appId: '4J81xwLy9vrYOytbLOns5bwe-gzGzoHsz',
      appKey: 'B9fhoOdq525uv4Q5v7ugQj6q',
      placeholder: '您不再踩踩嘛ಠ_ಠ',
      avatar: 'hide',
      meta: 'nick,mail,link'.split(','),
      pageSize: '5',
      lang: 'en',
      recordIP: false,
      serverURLs: '',
      emojiCDN: '',
      emojiMaps: "",
      enableQQ: true,
      path: window.location.pathname,
      requiredFields: ["nick,mail"],
      visitor: false
    }, null))
  }

  if (typeof Valine === 'function') initValine() 
  else getScript('https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js').then(initValine)
}

if ('Valine' === 'Valine' || !true) {
  if (true) btf.loadComment(document.getElementById('vcomment'),loadValine)
  else setTimeout(loadValine, 0)
} else {
  function loadOtherComment () {
    loadValine()
  }
}</script></div><script src="/js/toos.js"></script><script src="/js/flower.js"></script><script defer="defer" id="fluttering_ribbon" mobile="true" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-fluttering-ribbon.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><!-- hexo injector body_end start --><script async src="//at.alicdn.com/t/font_2032782_8d5kxvn09md.js"></script><!-- hexo injector body_end end --><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"log":false,"model":null,"use":"live2d-widget-model-koharu","display":{"position":"left","width":100,"height":100},"mobile":{"show":true},"react":null,"opacity":0.9});</script><script async>window.onload=function(){var a=document.createElement('script'),b=document.getElementsByTagName('script')[0];a.type='text/javascript',a.async=!0,a.src='/sw-register.js?v='+Date.now(),b.parentNode.insertBefore(a,b)};</script></body></html>